import * as React from 'react';
import * as PropTypes from 'prop-types';
import { ChipListSelectionContext, ChipListFocusContext, ChipListDataContext } from './ChipList';
import { classNames, useDir, getTabIndex, Keys } from '@progress/kendo-react-common';
import { FOCUS_ACTION } from './focus-reducer';
import { DATA_ACTION } from './data-reducer';
import { SELECTION_ACTION } from './selection-reducer';
/**
 * Represents the Chip component.
 */
export var Chip = React.forwardRef(function (props, ref) {
    var target = React.useRef(null);
    var chipRef = React.useRef(null);
    var dir = useDir(chipRef, props.dir);
    React.useImperativeHandle(ref, function () { return target.current; });
    var _a = React.useContext(ChipListSelectionContext), selection = _a[0], dispatchSelection = _a[1];
    var _b = React.useContext(ChipListFocusContext), focus = _b[0], dispatchFocus = _b[1];
    var _c = React.useContext(ChipListDataContext), dispatchData = _c[1];
    var selected = React.useMemo(function () {
        return (props.selected || (Array.isArray(selection)
            ? selection.some(function (i) { return i === props.value; })
            : selection === props.value));
    }, [props.selected, props.value, selection]);
    var focused = React.useMemo(function () { return focus === props.value; }, [props.value, focus]);
    var look = React.useMemo(function () { return props.look || defaultProps.look; }, [props.look]);
    React.useEffect(function () {
        if (focused && chipRef.current) {
            chipRef.current.focus();
        }
    }, [focused]);
    // React.useEffect(() => dispatchItemsContext({type: FOCUS_ACTION.register, payload: target }), []);
    var handleClick = React.useCallback(function (event) {
        dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
        if (props.onClick) {
            props.onClick.call(undefined, {
                target: target,
                syntheticEvent: event
            });
        }
    }, [props.onClick, dispatchSelection, props.value]);
    var handleRemove = React.useCallback(function (event) {
        if (!props.removable) {
            return;
        }
        dispatchData({ type: DATA_ACTION.remove, payload: props.value, event: event });
        dispatchFocus({ type: FOCUS_ACTION.reset, payload: props.value, event: event });
        dispatchSelection({ type: SELECTION_ACTION.remove, payload: props.value, event: event });
        if (props.onRemove) {
            props.onRemove.call(undefined, {
                target: target,
                syntheticEvent: event
            });
        }
    }, [props.onRemove, props.removable, dispatchData, dispatchFocus, dispatchSelection]);
    var handleKeyDown = React.useCallback(function (event) {
        switch (event.keyCode) {
            case Keys.left:
                dispatchFocus({ type: FOCUS_ACTION.prev, payload: props.value, event: event });
                break;
            case Keys.right:
                dispatchFocus({ type: FOCUS_ACTION.next, payload: props.value, event: event });
                break;
            case Keys.enter:
                dispatchSelection({ type: SELECTION_ACTION.toggle, payload: props.value, event: event });
                break;
            case Keys.delete:
                handleRemove(event);
                break;
            default:
                break;
        }
        if (props.onKeyDown) {
            props.onKeyDown.call(undefined, {
                target: target,
                syntheticEvent: event
            });
        }
    }, [props.onKeyDown, dispatchFocus, dispatchSelection, handleRemove]);
    var handleFocus = React.useCallback(function (event) {
        dispatchFocus({ payload: props.value, type: FOCUS_ACTION.current, event: event });
        if (props.onFocus) {
            props.onFocus.call(undefined, {
                target: target,
                syntheticEvent: event
            });
        }
    }, [props.onFocus, dispatchFocus]);
    var handleBlur = React.useCallback(function (event) {
        if (props.onBlur) {
            props.onBlur.call(undefined, {
                target: target,
                syntheticEvent: event
            });
        }
    }, [props.onBlur]);
    return (React.createElement("div", { id: props.value, style: props.style, ref: chipRef, dir: dir, tabIndex: getTabIndex(props.tabIndex, props.disabled, undefined), className: classNames('k-chip', 'k-chip-filled', {
            'k-rtl': dir === 'rtl',
            'k-chip-disabled': props.disabled,
            'k-chip-selected': selected,
            'k-chip-focused': focused,
            'k-chip-success': props.type === 'success',
            'k-chip-warning': props.type === 'warning',
            'k-chip-error': props.type === 'error',
            'k-chip-info': props.type === 'info',
            'k-chip-has-icon': props.icon,
            'k-chip-outline': look === 'outlined',
            'k-chip-filled': look === 'filled',
            'aria-checked': props.selected,
            'aria-disabled': !props.selected,
            'aria-describedby': props.ariaDescribedBy
        }, props.className), onFocus: handleFocus, onBlur: handleBlur, onClick: handleClick, onKeyDown: handleKeyDown },
        React.createElement("span", { className: 'k-selected-icon-wrapper' }, selected &&
            React.createElement("span", { className: "k-selected-icon k-icon " + (props.selectedIcon || defaultProps.selectedIcon) })),
        props.icon && (React.createElement("span", { className: "k-icon k-chip-icon " + props.icon })),
        React.createElement("span", { className: 'k-chip-content' }, props.text &&
            React.createElement("span", { "aria-label": props.text, className: 'k-chip-label' }, props.text)),
        props.removable &&
            React.createElement("span", { className: 'k-remove-icon', onClick: handleRemove },
                React.createElement("span", { className: "k-icon " + props.removeIcon }))));
});
var propTypes = {
    id: PropTypes.string,
    text: PropTypes.string,
    value: PropTypes.any,
    type: PropTypes.oneOf([
        'none',
        'success',
        'warning',
        'error',
        'info'
    ]),
    dir: PropTypes.oneOf(['ltr', 'rtl']),
    removable: PropTypes.bool,
    removeIcon: PropTypes.string,
    disabled: PropTypes.bool,
    icon: PropTypes.string,
    selectedIcon: PropTypes.string,
    look: PropTypes.string,
    onRemove: PropTypes.func,
    dataItem: PropTypes.any,
    selected: PropTypes.bool,
    ariaDescribedBy: PropTypes.string
};
var defaultProps = {
    disabled: false,
    removable: false,
    selectedIcon: 'k-i-check',
    look: 'filled',
    removeIcon: 'k-i-close-circle',
    dir: 'ltr'
};
Chip.displayName = 'KendoReactChip';
// TODO: delete casting when @types/react is updated!
Chip.propTypes = propTypes;
Chip.defaultProps = defaultProps;
//# sourceMappingURL=Chip.js.map